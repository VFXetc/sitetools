#!python
# encoding: UTF-8


import argparse
import os
import sys
import re
from subprocess import call, check_call, check_output, CalledProcessError
    
import fiadmin.tools
from fiadmin.utils import colour
from sitetools.sites import Site, find_dev_sites


def error(message):
    print '   ', colour('ERROR:', fg='red', reset=True), str(message)

def warning(message):
    print '   ', colour('WARNING:', fg='yellow', reset=True), str(message)


def git_call(deployed_repo, *args, **kwargs):
    kwargs.setdefault('cwd', os.path.dirname(deployed_repo))
    cmd = ['git', '--git-dir', deployed_repo] 
    cmd.extend(args)
    return check_call(cmd, **kwargs)


def git_output(deployed_repo, *args, **kwargs):
    kwargs.setdefault('cwd', os.path.dirname(deployed_repo))
    cmd = ['git', '--git-dir', deployed_repo] 
    cmd.extend(args)
    return check_output(cmd, **kwargs)


def git_remotes(deployed_repo):
    remotes = {}
    for line in git_output(deployed_repo, 'remote', '-v').splitlines():
        line = line.strip()
        if not line:
            continue
        parts = line.split()
        remotes[parts[0]] = parts[1]
    return remotes


def git_status_counts(repo):
    counts = {}
    for line in git_output(repo, 'status', '--porcelain').splitlines():
        line = line.strip()
        if not line:
            continue
        status = line.split()[0]
        counts[status] = counts.get(status, 0) + 1
    return counts

def git_rev_parse(deployed_repo, original_name):
        
    name = original_name
    res = None
    visited = set()
    while not res or not re.match(r'^[0-9a-f]{40}$', res):
        
        if res and res.startswith('ref:'):
            name = res[4:].strip()
        
        if name in visited:
            raise ValueError('recursion in refs: %r at %r' % (name, res))
        visited.add(name)
        
        for args in [
            (deployed_repo, name),
            (deployed_repo, 'refs/heads', name),
            (deployed_repo, 'refs/remotes', name),
        ]:
            path = os.path.join(*args)
            if os.path.exists(path):
                res = open(path).read().strip()
                break
        else:
            # warning("Could not directly parse rev %r from %r in %r" % (name, original_name, deployed_repo))
            res = git_output(deployed_repo, 'rev-parse', '--verify', original_name).strip()
    
    return res or None


def git_distance(deployed_repo, left, right):
    try:
        out = git_output(deployed_repo, 'rev-list', '--left-right', '--count', '%s...%s' % (left, right))
    except CalledProcessError:
        return
    m = re.match(r'^\s*(\d+)\s+(\d+)\s*$', out)
    if not m:
        # print colour("WARNING:", bg='yellow', bright=True, reset=True), 'Could not get rev distance from %r to %r in %r' % (left, right, deployed_repo)
        return (0, 0)
    return int(m.group(1)), int(m.group(2))


parser = argparse.ArgumentParser()
parser.add_argument('-n', '--no-fetch', action='store_true')
parser.add_argument('-u', '--update', action='store_true')
parser.add_argument('-v', '--verbose', action='store_true')
parser.add_argument('name', nargs='*')
args = parser.parse_args()


# Find development virtualenvs.
dev_sites = find_dev_sites()
dev_venvs = [s for s in dev_sites if s.is_venv]
if dev_venvs:
    dev_site = dev_venvs[0]
    tool_dir = os.path.dirname(os.path.abspath(dev_site.prefix))
elif dev_sites:
    dev_site = dev_sites[0]
    tool_dir = os.path.abspath(dev_site.path)
else:
    print 'Could not find dev site.'
    exit(1)

pip = dev_site.which('pip')


tool_names = args.name or [x[0] for x in fiadmin.tools.TOOLS]
if tool_names == ['.']:
    tool_names = [os.path.basename(os.getcwd())]


tools = []
for tool_name in tool_names:
    tool_path = os.path.join(tool_dir, tool_name)
    exists = os.path.exists(tool_path)
    tools.append((tool_name, tool_path, exists))

# Filter out non-existant tools.
tools = [(name, path, exists) for name, path, exists in tools if exists or args.verbose]

if not tools:
    print 'No tools installed.'
    exit(0)


for tool_name, tool_path, exists in tools:

    print colour('==> ' + tool_name, fg='blue', reset=True)
    
    if not exists:
        if args.verbose:
            print '    Not installed.'
        continue
        
    tool_repo = os.path.join(tool_path, '.git')

    if not args.no_fetch:
        git_call(tool_repo, 'fetch', 'origin')
    local_head = git_rev_parse(tool_repo, 'HEAD')
    remote_head = git_rev_parse(tool_repo, 'origin/master')

    status_counts = git_status_counts(tool_repo)

    ahead, behind = git_distance(tool_repo, local_head, remote_head)

    if behind and args.update:

        if status_counts:
            error('Cannot fast forward; please clean working directory.')

        elif ahead:
            error('Cannot fast forward; please merge or rebase.')

        else:

            git_call(tool_repo, 'merge', '--ff-only', 'origin/master')
            if os.path.exists(os.path.join(tool_path, 'setup.py')):
                if pip:
                    check_call([pip, 'install', '-e', tool_path])
                else:
                    error('Development site "%s" does not have `pip` to install tool.' % dev_site.path)
            local_head = git_rev_parse(tool_repo, 'HEAD')
            ahead = behind = 0

    if ahead and behind:
        warning('You and the tool have forked; please rebase.')
        warning('There are %d local commit%s, and %d remote commit%s.' % (
            ahead, 's' if ahead > 1 else '', behind, 's' if behind > 1 else ''
        ))
    elif ahead:
        print '   ', colour('You are ahead by %d commit%s.' % (ahead, 's' if ahead > 1 else ''), fg='green', reset=True)
    elif behind:
        warning('You are behind by %d commit%s.' % (behind, 's' if behind > 1 else ''))

    if status_counts:
        print '   ', colour('Working directory is dirty.', fg='yellow', reset=True)

    elif not (ahead or behind):
        print '   ', colour('Up to date.', fg='green', reset=True)

