#!/usr/bin/env python
# encoding: UTF-8


import argparse
import os
import sys
import re
from subprocess import call, check_call

from sitetools.repos import git_call, git_status_counts, git_rev_parse, git_distance, iter_available_packages
from sitetools.sites import Site, find_dev_sites
from sitetools.utils import colour


def error(message):
    print '   ', colour('ERROR:', fg='red', reset=True), str(message)

def warning(message):
    print '   ', colour('WARNING:', fg='yellow', reset=True), str(message)


parser = argparse.ArgumentParser()
parser.add_argument('-n', '--no-fetch', action='store_true')
parser.add_argument('-u', '--update', action='store_true')
parser.add_argument('-v', '--verbose', action='store_true')
parser.add_argument('name', nargs='*')
args = parser.parse_args()


# Find development virtualenvs.
dev_sites = find_dev_sites()
dev_venvs = [s for s in dev_sites if s.is_venv]
if dev_venvs:
    dev_site = dev_venvs[0]
    tool_dir = os.path.dirname(os.path.abspath(dev_site.prefix))
elif dev_sites:
    dev_site = dev_sites[0]
    tool_dir = os.path.abspath(dev_site.path)
else:
    print 'Could not find dev site.'
    exit(1)

pip = dev_site.which('pip')


tool_names = args.name or [x['name'] for x in iter_available_packages()]
if tool_names == ['.']:
    tool_names = [os.path.basename(os.getcwd())]


tools = []
for tool_name in tool_names:
    tool_path = os.path.join(tool_dir, tool_name)
    exists = os.path.exists(tool_path)
    tools.append((tool_name, tool_path, exists))

# Filter out non-existant tools.
tools = [(name, path, exists) for name, path, exists in tools if exists or args.verbose]

if not tools:
    print 'No tools installed.'
    exit(0)


for tool_name, tool_path, exists in tools:

    print colour('==> ' + tool_name, fg='blue', reset=True)
    
    if not exists:
        if args.verbose:
            print '    Not installed.'
        continue
        
    tool_repo = os.path.join(tool_path, '.git')

    if not args.no_fetch:
        git_call(tool_repo, 'fetch', 'origin')
    local_head = git_rev_parse(tool_repo, 'HEAD')
    remote_head = git_rev_parse(tool_repo, 'origin/master')

    status_counts = git_status_counts(tool_repo)

    ahead, behind = git_distance(tool_repo, local_head, remote_head)

    if behind and args.update:

        if status_counts:
            error('Cannot fast forward; please clean working directory.')

        elif ahead:
            error('Cannot fast forward; please merge or rebase.')

        else:

            git_call(tool_repo, 'merge', '--ff-only', 'origin/master')
            if os.path.exists(os.path.join(tool_path, 'setup.py')):
                if pip:
                    check_call([pip, 'install', '-e', tool_path])
                else:
                    error('Development site "%s" does not have `pip` to install tool.' % dev_site.path)
            local_head = git_rev_parse(tool_repo, 'HEAD')
            ahead = behind = 0

    if ahead and behind:
        warning('You and the tool have forked; please rebase.')
        warning('There are %d local commit%s, and %d remote commit%s.' % (
            ahead, 's' if ahead > 1 else '', behind, 's' if behind > 1 else ''
        ))
    elif ahead:
        print '   ', colour('You are ahead by %d commit%s.' % (ahead, 's' if ahead > 1 else ''), fg='green', reset=True)
    elif behind:
        warning('You are behind by %d commit%s.' % (behind, 's' if behind > 1 else ''))

    if status_counts:
        print '   ', colour('Working directory is dirty.', fg='yellow', reset=True)

    elif not (ahead or behind):
        print '   ', colour('Up to date.', fg='green', reset=True)

