#!/usr/bin/env python

import argparse
import errno
import glob
import os
from subprocess import call, check_call

from sitetools.repos import iter_available_packages
from sitetools.sites import Site, find_dev_sites, get_dev_site_patterns


parser = argparse.ArgumentParser()
parser.add_argument('-l', '--list', action='store_true', help='list all availible tools')
parser.add_argument('-a', '--all', action='store_true', help='install all availible tools')
parser.add_argument('--rebuild', action='store_true', help='rebuild all installed tools')
parser.add_argument('name', nargs='*')
args = parser.parse_args()



tools = list(iter_available_packages())
name_to_tool = dict((tool['name'], tool) for tool in tools)

if args.list:
    for tool in tools:
        print '{name:24s} {repo}'.format(**tool)
    exit(0)


dev_sites = find_dev_sites()
if dev_sites:
    tool_dir = dev_sites[0].path
else:
    tool_dir = os.path.expanduser(get_dev_site_patterns()[0])
    try:
        os.makedirs(tool_dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


names = [tool['name'] for tool in tools] if args.all or args.rebuild else args.name
if args.rebuild:
    names = [name for name in names if os.path.exists(os.path.join(tool_dir, name))]


for name in names:

    repo = name_to_tool.get(name, {}).get('repo')
    if not repo:
        print 'Tool %r is unknown.' % name
        exit(1)

    tool_path = os.path.join(tool_dir, name)

    if not os.path.exists(tool_path):
        check_call(['git', 'clone', repo, name], cwd=tool_dir)
    
    if os.path.exists(os.path.join(tool_path, 'setup.py')):
        check_call(['python', 'setup.py', 'egg_info'], cwd=tool_path)

        dirs_to_link = set()
        for top_level in glob.glob(os.path.join(tool_path, '*.egg-info', 'top_level.txt')):
            for line in open(top_level):
                dirs_to_link.add(os.path.dirname(os.path.join(name, line)))

        pth_path = os.path.join(tool_dir, 'dev_install.pth')
        print 'writing', pth_path

        # Get existing lines, but strip out the current project.
        pth_lines = []
        if os.path.exists(pth_path):
            section = None
            for line in open(pth_path):
                if line.startswith('#'):
                    section = line[1:].strip()
                if section != name:
                    pth_lines.append(line.rstrip())
        else:
            pth_lines.append('# autogenerated by dev_install')

        pth_lines.append('# ' + name)
        pth_lines.extend(sorted(dirs_to_link))

        with open(pth_path, 'w') as fh:
            fh.write('\n'.join(pth_lines))
            fh.write('\n')



